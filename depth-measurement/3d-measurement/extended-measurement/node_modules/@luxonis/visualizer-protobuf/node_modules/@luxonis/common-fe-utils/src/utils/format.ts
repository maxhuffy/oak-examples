import { format as formatTz, toZonedTime } from 'date-fns-tz';
import { differenceInMinutes, format, formatDuration, fromUnixTime } from 'date-fns';

import intl from './intl.js';
import { DAY, HOUR, MINUTE, SECOND } from './datetime.js';

const BYTES_ABBREVIATIONS = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
const BITS_PER_SEC_ABBREVIATIONS = ['bps', 'kbps', 'Mbps', 'Gbps', 'Tbps', 'Pbps', 'Ebps', 'Zbps', 'Ybps'];

const clamp = (min: number, max: number, value: number) => Math.min(Math.max(value, min), max);

const bytesFormatter =
  (abbr: string[], base: number, lnBase = Math.log(base)) =>
  (valueRaw: unknown, fmt = 'bytes') => {
    let value = valueRaw;

    if (typeof valueRaw === 'bigint' || typeof valueRaw === 'string') {
      value = Number(valueRaw);
    }

    // handle some special cases
    if (value === 0 || typeof value !== 'number') {
      return `0 ${abbr[0]}`;
    }

    const unit = clamp(0, abbr.length - 1, Math.floor(Math.log(value) / lnBase));

    const result = value / base ** unit;
    const maximumFractionDigits = unit > 2 ? 1 : 0; // show fraction value only for MB and below.

    return `${intl.formatNumber(result, {
      format: fmt,
      maximumFractionDigits,
    })} ${abbr[unit]}`;
  };

export const formatBps = bytesFormatter(BITS_PER_SEC_ABBREVIATIONS, 1000);

export const formatBytes = bytesFormatter(BYTES_ABBREVIATIONS, 1024);

export function formatTemperature(value: number): string {
  return `${intl.formatNumber(value, { format: 'temperature' })} °C`;
}

export function formatIntTemperature(value: number): string {
  return `${intl.formatNumber(value / 100.0, { format: 'temperature', maximumFractionDigits: 1 })} °C`;
}

export function formatLastSeen(lastSeen: Date | string | undefined | null): string {
  if (!lastSeen) return '-';
  const normalizedDate = new Date(lastSeen);
  const now = new Date();

  const diff = differenceInMinutes(now, normalizedDate);
  if (diff < 1) {
    return `moments ago`;
  } else if (diff < 60) {
    // 1 hour
    return `${formatDuration({ minutes: diff })} ago`;
  } else if (diff < 1440) {
    // 1 day
    return `${formatDuration({ hours: Math.floor(diff / 60) })} ago`;
  } else if (diff < 43200) {
    // 30 days
    return `${formatDuration({ days: Math.floor(diff / 1440) })} ago`;
  }

  return formatPrettyDate(normalizedDate);
}

export function formatUptime(uptimeInit: number, compact = true): string {
  let uptime = uptimeInit;
  if (!uptime) {
    return '0s';
  }

  uptime *= SECOND;
  const days = Math.floor(uptime / DAY);
  let rem = uptime - days * DAY;
  const hours = Math.floor(rem / HOUR);
  rem = uptime - hours * HOUR;
  const minutes = Math.floor(rem / MINUTE);
  rem = uptime - minutes * MINUTE;
  const seconds = Math.floor(rem / SECOND);

  if (compact) {
    if (days > 0) {
      return `${intl.formatNumber(days)}d ${hours}h`;
    }
    if (hours > 0) {
      return `${hours}h ${minutes}m`;
    }
    if (minutes) {
      return `${minutes}m ${seconds}s`;
    }
    return `${seconds}s`;
  }

  return `${days}d ${hours}h ${minutes}m ${seconds}s`;
}

export function formatPrettyDate(date: Date): string {
  return format(date, 'd/MM/yyyy');
}

export function formatPlatform(platformString: string | null | undefined): string {
  if (platformString?.startsWith('linux')) {
    return 'Self-Hosted';
  }
  if (platformString?.startsWith('keembay')) {
    const parts = platformString.split('/');
    if (parts.length === 1) {
      return 'Luxonis OS';
    } else if (parts.length === 2) {
      return `${parts[1] === 'arm64' ? 'RVC3' : 'RAE'}`;
    }
  }

  return 'Unknown';
}

export function formatCapitalizeFirstLetter(text: string): string {
  if (!text) return text;
  return text.charAt(0).toUpperCase() + text.substring(1).toLowerCase();
}

export function formatCapitalizeWords(sentence: string): string {
  return sentence
    .split(' ')
    .map(element => formatCapitalizeFirstLetter(element))
    .join(' ');
}

export function formatMaxLength(value: string, maxLength: number, ellipsis = false): string {
  if (maxLength <= 1 && ellipsis) {
    return '…';
  }
  if (value.length > maxLength) {
    const truncated = value.substring(0, maxLength - Number(ellipsis));
    return `${truncated}${ellipsis ? '…' : ''}`;
  }
  return value;
}

export function formatUsbPort(value: string | null): string {
  if (value === null) {
    return 'USB';
  }
  return `USB | port ${value}`;
}

export function formatRobotName(value: string | null): string {
  if (value === null) {
    return '-';
  }
  return value;
}

export function formatAgentVersion(version: string | number | bigint): string {
  try {
    const [year, day, time] = formatTz(toZonedTime(fromUnixTime(Number(version)), 'UTC'), 'yy.D.Hmm', {
      timeZone: 'UTC',
      awareOfUnicodeTokens: true,
      useAdditionalDayOfYearTokens: true,
    } as any).split('.');
    return `${year}.${day.padStart(3, '0')}.${time.padStart(4, '0')}`;
  } catch {
    return String(version);
  }
}

export function formatFirmwareVersion(version: string | undefined | null): string {
  if (!version) {
    return 'Unknown Version';
  }

  return version.replace('${distro_type}', '');
}
export function formatSlug(value: string): string {
  return value.replaceAll(' ', '-').toLowerCase();
}
